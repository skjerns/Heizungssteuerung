<!-- index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radiator</title>
  <style>
    :root{
      --bg0:#070a12;
      --card0:rgba(255,255,255,.10);
      --card1:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.94);
      --muted:rgba(255,255,255,.62);
      --muted2:rgba(255,255,255,.44);

      --ok-bg: rgba(10, 60, 28, .65);
      --ok-br: rgba(90, 255, 160, .25);

      --warn-bg: rgba(70, 40, 0, .70);
      --warn-br: rgba(255, 190, 80, .28);

      --bad-bg: rgba(85, 10, 10, .75);
      --bad-br: rgba(255, 110, 110, .24);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:
        radial-gradient(900px 520px at 50% 15%, #213a64 0%, var(--bg0) 60%, #05060c 100%);
      color:var(--text);
      display:grid;
      place-items:center;
      padding:22px;
    }
    .card{
      width:min(760px, 96vw);
      border-radius:22px;
      padding:18px 18px 14px;
      background:linear-gradient(180deg,var(--card0),var(--card1));
      border:1px solid rgba(255,255,255,.10);
      box-shadow:0 30px 90px rgba(0,0,0,.60);
      backdrop-filter: blur(10px);
    }
    .top{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      padding:2px 4px 8px;
    }
    .title{font-size:15px; letter-spacing:.3px}
    .status{font-size:13px;color:var(--muted)}

    .tabs{
      display:flex;
      gap:8px;
      padding:6px 4px 12px;
    }
    .tabbtn{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.82);
      border-radius:999px;
      padding:8px 12px;
      font-size:12px;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      transition: background .15s, border-color .15s, transform .05s;
    }
    .tabbtn:active{ transform: translateY(1px); }
    .tabbtn.active{
      background:rgba(255,255,255,.12);
      border-color:rgba(255,255,255,.22);
      color:rgba(255,255,255,.95);
    }

    .view{ display:none; }
    .view.active{ display:block; }

    /* CONTROL VIEW */
    .temp-boxes{
      display:flex;
      justify-content:space-around;
      gap:16px;
      padding:6px 0 18px;
    }
    .temp-box{
      background: var(--card1);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px 14px;
      text-align: center;
      flex: 1;
      transition: background .2s, border-color .2s, box-shadow .2s;
      min-width: 0;
    }
    .temp-box.fresh{
      background: var(--ok-bg);
      border-color: var(--ok-br);
    }
    .temp-box.warn{
      background: var(--warn-bg);
      border-color: var(--warn-br);
    }
    .temp-box.stale{
      background: var(--bad-bg);
      border-color: var(--bad-br);
    }

    /* thermostat.php fetch status (left box only) */
    .temp-box.sync-ok{
      box-shadow: 0 0 0 1px rgba(90,255,160,.18), 0 0 22px rgba(90,255,160,.08) inset;
    }
    .temp-box.sync-fail{
      box-shadow: 0 0 0 1px rgba(255,110,110,.14);
    }
    .temp-box.manual{
      box-shadow:none;
    }

    /* setpoint send feedback (left box) */
    .temp-box.pending{
      background: var(--warn-bg);
      border-color: var(--warn-br);
      box-shadow: 0 0 0 1px rgba(255,190,80,.18), 0 0 22px rgba(255,190,80,.08) inset;
    }
    .temp-box.applied-ok{
      background: var(--ok-bg);
      border-color: var(--ok-br);
      box-shadow: 0 0 0 1px rgba(90,255,160,.18), 0 0 22px rgba(90,255,160,.08) inset;
    }
    .temp-box.applied-fail{
      background: var(--bad-bg);
      border-color: var(--bad-br);
      box-shadow: 0 0 0 1px rgba(255,110,110,.14);
    }

    .temp-label{
      font-size: 12px;
      color: rgba(255,255,255,.72);
      margin-bottom: 2px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .dot{
      width:8px;height:8px;border-radius:99px; display:inline-block;
      background: rgba(255,255,255,.25);
      flex:0 0 auto;
    }
    .dot.ok{ background: rgba(90,255,160,.85); }
    .dot.bad{ background: rgba(255,110,110,.85); }
    .dot.off{ background: rgba(255,255,255,.20); }

    /* spinner while thermostat.php?get is pending */
    .dot.spin{
      width:12px;height:12px;
      background: transparent;
      border:2px solid rgba(255,255,255,.25);
      border-top-color: rgba(255,255,255,.78);
      border-radius:50%;
      animation: spin .8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .temp-value{
      font-size: 22px;
      font-weight: 600;
      line-height:1.2;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .dialWrap{display:grid;place-items:center; padding:6px 0 0}
    svg{width:100%; height:auto; user-select:none; touch-action:none}
    .track{
      fill:none;
      stroke:rgba(255,255,255,.13);
      stroke-width:18;
      stroke-linecap:round;
    }
    .active{
      fill:none;
      stroke:url(#activeGrad);
      stroke-width:18;
      stroke-linecap:round;
      filter:url(#glow);
    }
    .tick{
      stroke:rgba(255,255,255,.18);
      stroke-width:2;
      stroke-linecap:round;
    }
    .knob{cursor:grab}
    .knob.grabbing{cursor:grabbing}
    .knobOuter{
      fill:rgba(255,255,255,.95);
      stroke:rgba(0,0,0,.25);
      stroke-width:1;
    }
    .knobInner{fill:rgba(0,0,0,.35)}
    .hintText{
      font-size:12px;
      fill:var(--muted2);
      letter-spacing:1.2px;
      text-transform:uppercase;
    }
    .bottom{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      padding:8px 4px 0;
    }
    .range{font-size:12px;color:var(--muted2)}
    .net{font-size:12px;color:var(--muted2)}

    /* GRAPH VIEW */
    .graphWrap{
      padding:6px 2px 2px;
    }
    .graphHead{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:12px;
      padding:0 4px 10px;
    }
    .graphTitle{
      font-size:13px;
      color:rgba(255,255,255,.86);
      letter-spacing:.2px;
    }
    .graphHint{
      font-size:12px;
      color:var(--muted2);
      white-space:nowrap;
    }
    .canvasWrap{
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
      overflow:hidden;
    }
    #tempChart{
      width:100%;
      height:320px;
      display:block;
    }
  </style>
</head>

<body>
  <div class="card">
    <div class="top">
      <div class="title">Radiator</div>
      <div class="status" id="status">idle</div>
    </div>

    <div class="tabs" role="tablist" aria-label="Views">
      <button class="tabbtn active" id="tabControl" role="tab" aria-selected="true">Control</button>
      <button class="tabbtn" id="tabGraph" role="tab" aria-selected="false">Graph</button>
    </div>

    <!-- CONTROL VIEW -->
    <div class="view active" id="viewControl" role="tabpanel" aria-labelledby="tabControl">
      <div class="temp-boxes">
        <div id="set-temp-box" class="temp-box">
          <div class="temp-label">
            <span class="dot off" id="set-sync-dot" aria-hidden="true"></span>
            <span>Set</span>
          </div>
          <div id="set-temp-value" class="temp-value">--.-°C</div>
        </div>

        <div id="room-temp-box" class="temp-box">
          <div class="temp-label">Room</div>
          <div id="room-temp-value" class="temp-value">--.-°C</div>
        </div>
      </div>

      <div class="dialWrap">
        <svg id="dial" viewBox="0 0 360 240" aria-label="Temperature control">
          <defs>
            <linearGradient id="activeGrad" x1="0" y1="0" x2="1" y2="0">
              <stop offset="0%" stop-color="#67d4ff"/>
              <stop offset="100%" stop-color="#8affc1"/>
            </linearGradient>

            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="2.5" result="b"/>
              <feMerge>
                <feMergeNode in="b"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>

            <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
              <feDropShadow dx="0" dy="10" stdDeviation="10" flood-opacity=".35"/>
            </filter>
          </defs>

          <path id="track" class="track" d=""></path>
          <path id="active" class="active" d=""></path>

          <g id="ticks"></g>

          <g id="knob" class="knob" filter="url(#shadow)" tabindex="0" aria-label="Temperature knob">
            <circle class="knobOuter" cx="0" cy="0" r="14"></circle>
            <circle class="knobInner" cx="0" cy="0" r="6"></circle>
          </g>

          <g>
            <text x="180" y="170" text-anchor="middle" class="hintText">drag</text>
          </g>
        </svg>
      </div>

      <div class="bottom">
        <div class="range" id="range"></div>
        <div class="net" id="net">idle</div>
      </div>
    </div>

    <!-- GRAPH VIEW -->
    <div class="view" id="viewGraph" role="tabpanel" aria-labelledby="tabGraph">
      <div class="graphWrap">
        <div class="graphHead">
          <div class="graphTitle">Temperature history</div>
          <div class="graphHint">drag to pan · wheel/pinch to zoom</div>
        </div>
        <div class="canvasWrap">
          <canvas id="tempChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Chart.js + pan/zoom plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js" defer></script>

  <!-- graph view code -->
  <script src="./graph.js" defer></script>

<script>
const CFG = {
  THERMOSTAT_URL: './thermostat.php',
  STATUS_URL: './status.php',

  MIN_TEMP: 15.0,
  MAX_TEMP: 25.0,
  STEP: 0.5,

  CX: 180,
  CY: 190,
  R: 120,

  ARC_SPAN_DEG: 130,
  ARC_CENTER_DEG: 270,

  SEND_DELAY_MS: 1000,
  FETCH_TIMEOUT_MS: 5000,
};

const el = {
  tabControl: document.getElementById('tabControl'),
  tabGraph: document.getElementById('tabGraph'),
  viewControl: document.getElementById('viewControl'),
  viewGraph: document.getElementById('viewGraph'),

  dial: document.getElementById('dial'),
  track: document.getElementById('track'),
  active: document.getElementById('active'),
  knob: document.getElementById('knob'),
  ticks: document.getElementById('ticks'),
  status: document.getElementById('status'),
  range: document.getElementById('range'),
  net: document.getElementById('net'),

  roomTempBox: document.getElementById('room-temp-box'),
  roomTempValue: document.getElementById('room-temp-value'),

  setTempBox: document.getElementById('set-temp-box'),
  setTempValue: document.getElementById('set-temp-value'),
  setSyncDot: document.getElementById('set-sync-dot'),
};

const state = {
  value: 20.0,
  dragging: false,
  manualOverride: false,
  sendTimer: null,
  lastSent: null,

  pollSeq: 0,
  feedbackTimer: null,
};

const ARC_START = CFG.ARC_CENTER_DEG - CFG.ARC_SPAN_DEG / 2;
const ARC_END   = CFG.ARC_CENTER_DEG + CFG.ARC_SPAN_DEG / 2;

init();

function init() {
  bindTabs();

  el.range.textContent = `${CFG.MIN_TEMP.toFixed(1)}°C  ${CFG.MAX_TEMP.toFixed(1)}°C`;
  el.track.setAttribute('d', arcPath(CFG.CX, CFG.CY, CFG.R, ARC_START, ARC_END));
  buildTicks();
  setValue(clampSnap(20.0), true);

  bindPointer();
  bindKeyboard();

  // single load only; no reload interval
  updateAll();
}

function bindTabs() {
  const show = (which) => {
    const isControl = which === 'control';

    el.tabControl.classList.toggle('active', isControl);
    el.tabGraph.classList.toggle('active', !isControl);
    el.tabControl.setAttribute('aria-selected', isControl ? 'true' : 'false');
    el.tabGraph.setAttribute('aria-selected', !isControl ? 'true' : 'false');

    el.viewControl.classList.toggle('active', isControl);
    el.viewGraph.classList.toggle('active', !isControl);

    if (!isControl && window.GraphView && typeof window.GraphView.ensureLoaded === 'function') {
      window.GraphView.ensureLoaded();
    }
  };

  el.tabControl.addEventListener('click', () => show('control'));
  el.tabGraph.addEventListener('click', () => show('graph'));
}

function setSyncDot(mode) {
  // mode: 'loading' | 'ok' | 'bad' | 'off'
  el.setSyncDot.classList.remove('ok','bad','off','spin');
  if (mode === 'loading') { el.setSyncDot.classList.add('spin'); return; }
  if (mode === 'ok') { el.setSyncDot.classList.add('ok'); return; }
  if (mode === 'bad') { el.setSyncDot.classList.add('bad'); return; }
  el.setSyncDot.classList.add('off');
}

function setSetBoxFeedback(kind) {
  // kind: 'pending' | 'ok' | 'fail' | 'clear'
  el.setTempBox.classList.remove('pending','applied-ok','applied-fail');

  if (state.feedbackTimer) clearTimeout(state.feedbackTimer);
  state.feedbackTimer = null;

  if (kind === 'pending') {
    el.setTempBox.classList.add('pending');
    return;
  }
  if (kind === 'ok') {
    el.setTempBox.classList.add('applied-ok');
    state.feedbackTimer = setTimeout(() => setSetBoxFeedback('clear'), 1500);
    return;
  }
  if (kind === 'fail') {
    el.setTempBox.classList.add('applied-fail');
    state.feedbackTimer = setTimeout(() => setSetBoxFeedback('clear'), 2000);
    return;
  }
}

async function updateAll() {
  const seq = ++state.pollSeq;
  el.status.textContent = 'loading&';

  const shouldFetchThermo = !state.manualOverride;

  let thermoPromise = Promise.resolve({ ok: false, skipped: true });
  if (shouldFetchThermo) {
    setSyncDot('loading');
    el.setTempBox.classList.remove('sync-ok', 'sync-fail');
    thermoPromise = fetchThermostatValue(`${CFG.THERMOSTAT_URL}?get`, CFG.FETCH_TIMEOUT_MS)
      .then(v => ({ ok: true, v }))
      .catch(err => ({ ok: false, err }));
  } else {
    setSyncDot('off');
  }

  let statusData = null;
  try {
    statusData = await fetchJson(CFG.STATUS_URL, CFG.FETCH_TIMEOUT_MS);
  } catch {
    statusData = null;
  }

  if (statusData && statusData.room_temp) {
    const parsed = parseStampedTemp(statusData.room_temp);
    if (parsed) {
      el.roomTempValue.textContent = `${parsed.temp.toFixed(1)}°C`;
      applyFreshness(el.roomTempBox, parsed.ageMin);
    } else {
      markBad(el.roomTempBox);
      el.roomTempValue.textContent = '--.-°C';
    }
  } else {
    markBad(el.roomTempBox);
    el.roomTempValue.textContent = '--.-°C';
  }

  if (!state.manualOverride) {
    let eq3Parsed = null;
    if (statusData && statusData.eq3_temp) eq3Parsed = parseStampedTemp(statusData.eq3_temp);

    if (eq3Parsed) {
      applyFreshness(el.setTempBox, eq3Parsed.ageMin);
      el.setTempValue.textContent = `${eq3Parsed.temp.toFixed(1)}°C`;
      if (!state.dragging) setValue(clampSnap(eq3Parsed.temp), true);
    } else {
      markBad(el.setTempBox);
      el.setTempValue.textContent = '--.-°C';
    }
  } else {
    el.setTempBox.classList.add('manual');
  }

  el.status.textContent = (statusData ? 'ready' : 'status failed');

  const thermoRes = await thermoPromise;
  if (seq !== state.pollSeq) return;
  if (state.manualOverride) return;
  if (thermoRes.skipped) return;

  el.setTempBox.classList.remove('sync-ok', 'sync-fail');

  if (thermoRes.ok && Number.isFinite(thermoRes.v)) {
    setSyncDot('ok');
    el.setTempBox.classList.add('sync-ok');

    el.setTempBox.classList.remove('warn', 'stale');
    el.setTempBox.classList.add('fresh');

    el.setTempValue.textContent = `${thermoRes.v.toFixed(1)}°C`;
    if (!state.dragging) setValue(clampSnap(thermoRes.v), true);
  } else {
    setSyncDot('bad');
    el.setTempBox.classList.add('sync-fail');
  }
}

function markBad(boxEl) {
  boxEl.classList.remove('fresh','warn','stale');
  boxEl.classList.add('stale');
}

function applyFreshness(boxEl, ageMin) {
  boxEl.classList.remove('fresh','warn','stale');
  if (!Number.isFinite(ageMin)) {
    boxEl.classList.add('stale');
    return;
  }
  if (ageMin > 45) boxEl.classList.add('stale');
  else if (ageMin > 10) boxEl.classList.add('warn');
  else boxEl.classList.add('fresh');
}

function parseStampedTemp(s) {
  if (!s || typeof s !== 'string') return null;
  const idx = s.indexOf(',');
  if (idx === -1) return null;

  const datetimeStr = s.slice(0, idx).trim();
  const tempStrRaw = s.slice(idx + 1).trim();

  const tempStr = tempStrRaw.replace(',', '.');
  const temp = parseFloat(tempStr);
  if (!Number.isFinite(temp)) return null;

  const t = parseDateTimeLocal(datetimeStr);
  if (!Number.isFinite(t)) return { temp, ageMin: NaN };

  const now = Date.now();
  const ageMs = Math.max(0, now - t);
  const ageMin = ageMs / 60000;

  return { temp, ageMin };
}

function parseDateTimeLocal(dt) {
  const iso = dt.replace(' ', 'T');
  const d = new Date(iso);
  const t = d.getTime();
  return Number.isFinite(t) ? t : NaN;
}

async function fetchJson(url, timeoutMs) {
  const controller = new AbortController();
  const to = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const r = await fetch(url, { cache:'no-store', signal: controller.signal });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return await r.json();
  } finally {
    clearTimeout(to);
  }
}

async function fetchThermostatValue(url, timeoutMs) {
  const controller = new AbortController();
  const to = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const r = await fetch(url, { cache:'no-store', signal: controller.signal });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const txt = (await r.text()).trim();
    const v = parseFloat(txt.replace(',', '.'));
    if (!Number.isFinite(v)) throw new Error('bad value');
    return v;
  } finally {
    clearTimeout(to);
  }
}

function buildTicks() {
  const g = el.ticks;
  g.textContent = '';
  for (let t = CFG.MIN_TEMP; t <= CFG.MAX_TEMP + 1e-9; t += 1.0) {
    const a = angleFromValue(t);
    const p0 = polar(CFG.CX, CFG.CY, CFG.R - 22, a);
    const p1 = polar(CFG.CX, CFG.CY, CFG.R - 12, a);

    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', p0.x.toFixed(3));
    line.setAttribute('y1', p0.y.toFixed(3));
    line.setAttribute('x2', p1.x.toFixed(3));
    line.setAttribute('y2', p1.y.toFixed(3));
    line.setAttribute('class', 'tick');
    g.appendChild(line);
  }
}

function bindPointer() {
  el.dial.addEventListener('pointerdown', (e) => {
    state.dragging = true;
    el.knob.classList.add('grabbing');
    el.dial.setPointerCapture(e.pointerId);
    cancelSend();
    applyPointer(e);
  });

  el.dial.addEventListener('pointermove', (e) => {
    if (!state.dragging) return;
    applyPointer(e);
  });

  el.dial.addEventListener('pointerup', (e) => {
    if (!state.dragging) return;
    state.dragging = false;
    el.knob.classList.remove('grabbing');
    try { el.dial.releasePointerCapture(e.pointerId); } catch {}
    scheduleSend();
  });

  el.dial.addEventListener('pointercancel', () => {
    state.dragging = false;
    el.knob.classList.remove('grabbing');
    scheduleSend();
  });
}

function bindKeyboard() {
  el.knob.addEventListener('keydown', (e) => {
    if (!['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) return;
    e.preventDefault();
    const dir = (e.key === 'ArrowRight' || e.key === 'ArrowUp') ? 1 : -1;
    cancelSend();
    setValue(clampSnap(state.value + dir * CFG.STEP), false);
    scheduleSend();
  });
}

function applyPointer(e) {
  const p = clientToViewBoxPoint(e.clientX, e.clientY, el.dial);
  const ang = angleDeg(p.x - CFG.CX, p.y - CFG.CY);
  const a = clamp(ang, ARC_START, ARC_END);
  setValue(valueFromAngle(a), false);
}

function setValue(v, silent) {
  const next = clampSnap(v);

  if (!silent && next !== state.value) {
    state.manualOverride = true;
    el.setTempBox.classList.add('manual');
    setSyncDot('off');
  }

  state.value = next;

  const a = angleFromValue(state.value);
  const kp = polar(CFG.CX, CFG.CY, CFG.R, a);
  el.knob.setAttribute('transform', `translate(${kp.x.toFixed(3)} ${kp.y.toFixed(3)})`);

  el.active.setAttribute('d', arcPath(CFG.CX, CFG.CY, CFG.R, ARC_START, a));

  el.setTempValue.textContent = `${state.value.toFixed(1)}°C`;
  if (!silent) el.status.textContent = 'set&';
}

function scheduleSend() {
  cancelSend();
  state.sendTimer = setTimeout(() => sendToThermostat(state.value), CFG.SEND_DELAY_MS);
}

function cancelSend() {
  if (state.sendTimer) clearTimeout(state.sendTimer);
  state.sendTimer = null;
}

function sendToThermostat(v) {
  const valueStr = v.toFixed(1);
  if (state.lastSent === valueStr) {
    el.net.textContent = 'idle';
    el.status.textContent = 'ready';
    return;
  }

  const url = `${CFG.THERMOSTAT_URL}?set=${encodeURIComponent(valueStr)}`;
  el.net.textContent = 'sending&';
  setSetBoxFeedback('pending');

  const img = new Image();
  img.onload = () => {
    state.lastSent = valueStr;
    el.net.textContent = 'sent';
    el.status.textContent = 'ready';
    setSetBoxFeedback('ok');
  };
  img.onerror = () => {
    state.lastSent = valueStr;
    el.net.textContent = 'sent?';
    el.status.textContent = 'ready';
    setSetBoxFeedback('fail');
  };
  img.src = url;
}

function clampSnap(v) {
  const c = clamp(v, CFG.MIN_TEMP, CFG.MAX_TEMP);
  const n = Math.round((c - CFG.MIN_TEMP) / CFG.STEP);
  const snapped = CFG.MIN_TEMP + n * CFG.STEP;
  return Number(snapped.toFixed(1));
}

function valueFromAngle(a) {
  const t = (a - ARC_START) / (ARC_END - ARC_START);
  return clampSnap(CFG.MIN_TEMP + t * (CFG.MAX_TEMP - CFG.MIN_TEMP));
}

function angleFromValue(v) {
  const t = (v - CFG.MIN_TEMP) / (CFG.MAX_TEMP - CFG.MIN_TEMP);
  return ARC_START + t * (ARC_END - ARC_START);
}

function arcPath(cx, cy, r, startDeg, endDeg) {
  const s = polar(cx, cy, r, startDeg);
  const e = polar(cx, cy, r, endDeg);
  const delta = Math.abs(endDeg - startDeg);
  const largeArc = delta > 180 ? 1 : 0;
  const sweep = 1;
  return `M ${s.x.toFixed(3)} ${s.y.toFixed(3)} A ${r} ${r} 0 ${largeArc} ${sweep} ${e.x.toFixed(3)} ${e.y.toFixed(3)}`;
}

function polar(cx, cy, r, deg) {
  const rad = deg * Math.PI / 180;
  return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
}

function angleDeg(dx, dy) {
  let a = Math.atan2(dy, dx) * 180 / Math.PI;
  if (a < 0) a += 360;
  return a;
}

function clamp(x, a, b) {
  return Math.min(b, Math.max(a, x));
}

function clientToViewBoxPoint(clientX, clientY, svg) {
  const r = svg.getBoundingClientRect();
  const vb = svg.viewBox.baseVal;
  const x = (clientX - r.left) / r.width  * vb.width  + vb.x;
  const y = (clientY - r.top)  / r.height * vb.height + vb.y;
  return { x, y };
}
</script>
</body>
</html>
